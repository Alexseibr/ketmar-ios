PROMPT ДЛЯ CODEX / REPLIT: ФИЛЬТР ПОИСКА НА КАРТЕ ОБЪЯВЛЕНИЙ

Проект: KETMAR Market – Telegram Mini App.
Экран: "Карта объявлений" (Leaflet + OSM, верхняя строка с поиском, ниже выбор радиуса 300м / 1км / 3км / 5км / 10км / 20км).

Цель:
Сделать так, чтобы строка поиска на экране карты реально фильтровала объявления:

- Если я ввёл в поиске "Малина" – на карте остаются только объявления про малину, остальные пины исчезают.
- Если ввёл "телефон" – остаются только объявления с телефонами.
- Если ввёл "услуги" – только объявления с услугами.
- При очистке поиска (иконка X) – снова показываются все объявления в выбранном радиусе.

Нужно сделать фронтенд + бэкенд-логику фильтра.

Текущая ситуация:
- Карта уже показывает пины (Leaflet markers) в радиусе вокруг текущей точки.
- Есть готовый API для подтягивания объявлений рядом (что-то вроде GET /api/ads/map или GET /api/ads с параметрами lat, lng, radius).
- Верхний input поиска сейчас либо вообще не подключён к API, либо только визуальный.

Задача:

1) БЭКЕНД – ДОБАВИТЬ ПАРАМЕТР ПОИСКА

Добавить в endpoint, который используется для карты, новый query-параметр `q` (строка поиска).

Например:
  GET /api/ads/map?lat=...&lng=...&radius=10000&q=малина

Поведение бэкенда:
- Если q не передан или пустой → работать как сейчас (вернуть все объявления по радиусу).
- Если q передан → фильтровать объявления по этому запросу.

Фильтрация в MongoDB:
- Поиск по:
  * title,
  * description,
  * categoryName,
  * tags,
  * типу (goods/services/phones и т.п., если такие поля есть).
- Реализовать либо через `$text`, если есть текстовый индекс, либо через `$or` + `$regex` (case-insensitive).

Пример фильтра (адаптировать к реальной схеме):

  const q = req.query.q?.trim();
  const radiusMeters = Number(req.query.radius) || 10000;

  const geoFilter = {
    location: {
      $near: {
        $geometry: { type: "Point", coordinates: [lng, lat] },
        $maxDistance: radiusMeters
      }
    }
  };

  let textFilter = {};

  if (q) {
    const regex = new RegExp(q, "i");
    textFilter = {
      $or: [
        { title: regex },
        { description: regex },
        { categoryName: regex },
        { tags: regex },
        { type: regex } // если "услуги", "товары", "телефоны" лежат в type
      ]
    };
  }

  const ads = await Ad.find({
    ...geoFilter,
    ...textFilter,
    status: "active"
  });

Вернуть тот же JSON, что и сейчас, чтобы фронтенд не ломать.

2) ФРОНТЕНД – ПОДКЛЮЧИТЬ ПОИСК К API КАРТЫ

Экран карты (React-компонент, допустим `MapScreen.tsx` или `AdsMap.tsx`) уже имеет:
- состояние текущей гео-точки (lat, lng),
- выбранный радиус,
- список `ads` для отображения на карте,
- строку поиска (input с placeholder "Малина" и кнопкой X).

Нужно:

2.1. Добавить локальное состояние для строки поиска:

  const [searchQuery, setSearchQuery] = useState("");

2.2. Повесить onChange на input:

  <input
    value={searchQuery}
    onChange={(e) => setSearchQuery(e.target.value)}
    placeholder="Малина"
    ... />

2.3. Сделать debounce (например 300–500 мс), чтобы не дёргать API на каждый символ.
Можно использовать lodash.debounce или свой hook.

Пример:

  const debouncedQuery = useDebouncedValue(searchQuery, 400);

  useEffect(() => {
    fetchAds();
  }, [lat, lng, radius, debouncedQuery]);

  async function fetchAds() {
    const params = new URLSearchParams({
      lat: String(lat),
      lng: String(lng),
      radius: String(radius)
    });

    if (debouncedQuery.trim()) {
      params.append("q", debouncedQuery.trim());
    }

    const res = await apiClient.get(`/api/ads/map?${params.toString()}`);
    setAds(res.data.ads);
  }

2.4. Кнопка "X" справа в строке поиска:
- При нажатии:
    setSearchQuery("");
- Это автоматически триггернёт `fetchAds()` без q и вернёт на карту все объявления.

2.5. Отображение маркеров:
- Никакой локальной фильтрации на клиенте не делаем, всё делает backend.
- Просто отображаем `ads` как сейчас:
    ads.map(ad => <Marker ... />)
- Если API вернул 0 объявлений – показать пустое состояние:
    "По вашему запросу в этом радиусе ничего не найдено" или просто пустую карту без пинов.

3) UX-МЕЛОЧИ

- По Enter в поле поиска:
  – можно сразу запускать `fetchAds()` (без ожидания debounce).
- Если пользователь меняет радиус (нажимает 300м/1км/3км…) – запрос к API должен идти с текущим debouncedQuery, т.е. поиск + радиус должны работать вместе.
- При открытии карты первый запрос – без q (все объявления в радиусе).

4) ПРОВЕРКА НА ПРИМЕРАХ

Нужно убедиться, что:

- Вбиваю "Малина" → остаются только пины с малиной.
- Вбиваю "телефон" → остаются только объявления, где в title/description/category/type есть телефон.
- Вбиваю "услуги" → остаются только объявления-услуги.
- Нажимаю X (очистка) → снова показываются все объявления как раньше.

Сделай:
- изменения в backend-роуте для карты,
- изменения в React-компоненте карты,
- при необходимости – небольшой debounce-хук.
Покажи финальный код роутера (backend) и компонента карты (frontend).
