 (cd "$(git rev-parse --show-toplevel)" && git apply --3way <<'EOF' 
diff --git a/.env.example b/.env.example
new file mode 100644
index 0000000000000000000000000000000000000000..4a11c6f823147441dea816a5eab81bbf7f9c2b11
--- /dev/null
+++ b/.env.example
@@ -0,0 +1,4 @@
+BOT_TOKEN=123456789:ABCDEF...
+MONGO_URL=mongodb://localhost:27017/miniapp
+PORT=3000
+API_BASE_URL=http://localhost:3000
diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000000000000000000000000000000000000..6e96afaedc912323dcaf593fde8fafe9d2ad236b
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,7 @@
+node_modules
+.env
+npm-debug.log*
+yarn-debug.log*
+yarn-error.log*
+pnpm-debug.log*
+.DS_Store
diff --git a/.replit b/.replit
new file mode 100644
index 0000000000000000000000000000000000000000..8e2893a31698437547a63880b77f9436863bc029
--- /dev/null
+++ b/.replit
@@ -0,0 +1,9 @@
+run = "npm install && npm start"
+entrypoint = "index.js"
+language = "nodejs"
+
+[env]
+PORT = "3000"
+
+[nix]
+channel = "stable-23.05"
diff --git a/README.md b/README.md
index 0256397edb74f864b292a040670f3498abd1f867..a9ed51512fb4fb078c0716b6f7dbea703e5b093e 100644
--- a/README.md
+++ b/README.md
@@ -1,2 +1,125 @@
 # miniapp
-отличный миниапп
+
+Backend и Telegram-бот для маркетплейса объявлений (Node.js 18+, Express, MongoDB/Mongoose, Telegraf).
+
+## Быстрый старт
+
+1. Скопируйте `.env.example` в `.env` и задайте переменные:
+   - `BOT_TOKEN` — токен Telegram-бота (если пуст, бот не запустится).
+   - `MONGO_URL` — строка подключения к MongoDB.
+   - `PORT` — порт API (по умолчанию 3000).
+   - `API_BASE_URL` — базовый URL API, который использует бот (по умолчанию `http://localhost:3000`).
+2. Установите зависимости:
+
+   ```bash
+   npm install
+   ```
+
+3. Запустите сервер и бота:
+
+   ```bash
+   npm start
+   # или с перезапуском
+   npm run dev
+   ```
+
+### Запуск в Replit
+
+- В репозитории уже есть файлы `.replit` и `replit.nix` с Node.js 18 и командой запуска.
+- В разделе Secrets добавьте значения `BOT_TOKEN` и `MONGO_URL` (если используете MongoDB Atlas).
+- Нажмите **Run** — Replit автоматически выполнит `npm install` и `npm start`.
+- API будет доступно на порту, который выдаст Replit; в консоли появится URL.
+
+4. (Опционально) Засейдите категории и пример сезона:
+
+   ```bash
+   npm run seed
+   ```
+
+## Структура проекта
+
+```
+project-root/
+  index.js                # точка входа: запускает API и бота
+  package.json
+  .env.example
+
+  /config
+    config.js             # чтение env, базовые константы
+
+  /services
+    db.js                 # подключение к MongoDB (mongoose)
+
+  /models
+    User.js
+    Category.js
+    Season.js
+    Ad.js
+    Order.js
+
+  /api
+    server.js             # создание Express-приложения
+    /routes
+      ads.js
+      categories.js
+      seasons.js
+      orders.js
+      users.js (заглушка)
+
+  /bot
+    bot.js                # Telegraf-бот
+
+  /scripts
+    seedCategories.js     # заполнение Category и Season стартовыми данными
+```
+
+## API
+
+- `GET /` — проверка базовой доступности API.
+- `GET /health` — healthcheck.
+
+### Категории
+- `GET /api/categories` — дерево категорий (parentSlug → subcategories), отсортировано по `sortOrder`.
+
+### Сезоны
+- `GET /api/seasons` — список всех сезонов.
+
+### Объявления
+- `GET /api/ads` — список активных объявлений. Query: `limit` (по умолчанию 20, максимум 100), опционально `categoryId`, `subcategoryId`, `seasonCode`. Ответ: `{ items: Ad[] }`.
+- `GET /api/ads/:id` — полное объявление по `_id`.
+- `POST /api/ads` — создать объявление. Обязательные поля: `title`, `categoryId`, `subcategoryId`, `price`, `sellerTelegramId`. Пример payload см. команду бота `/new_test_ad`.
+
+### Заказы
+- `POST /api/orders` — создать заказ. Бекенд подтягивает актуальные данные объявлений по `adId` (title, price, sellerTelegramId) и сохраняет итоговые `items`.
+- `GET /api/orders/:buyerTelegramId` — список заказов покупателя.
+
+## Модели (Mongoose)
+
+- **User**: Telegram-данные, роль, верификация телефона, соцсети, флаги приватности, локация.
+- **Category**: `slug`, `name`, `parentSlug`, `sortOrder`.
+- **Season**: `code`, `name`, `description`, `startDate`, `endDate`, `isActive`.
+- **Ad**: категории/подкатегории, цена + `currency` (BYN по умолчанию), гибкие `attributes`, `photos`, доставка, `sellerTelegramId`, `seasonCode`, статусы, `lifetimeDays` и авто-расчёт `validUntil`, `isLiveSpot`.
+- **Order**: покупатель (Telegram ID/имя/username/phone), массив `items` (adId, title, quantity, price, sellerTelegramId), `status`, `seasonCode`, `comment`.
+
+## Telegram-бот
+
+Токен берётся из `BOT_TOKEN`. Использует `API_BASE_URL` для запросов к API.
+
+Команды:
+- `/start` — приветствие и список команд.
+- `/myid` — ваш Telegram ID, username и имя.
+- `/categories` — дерево категорий из API.
+- `/new_test_ad` — создаёт тестовое объявление с вашим `sellerTelegramId`.
+
+Бот запускается вместе с API из `index.js`.
+
+## Seed-данные
+
+Скрипт `npm run seed` очищает `Category` и `Season`, затем добавляет базовые категории и сезон `march8_tulips`:
+- Авто: auto → cars, moto, trucks
+- Недвижимость: realty → rent_flat, rent_house, country_base
+- Фермерские товары: farm → berries, vegetables, fruits, eggs, milk, meat
+- Ремесленники: craft → cakes, eclairs, cupcakes, sweets_sets
+- Услуги: services → build, delivery_services
+- Сезон: `code = "march8_tulips"`, `name = "Ярмарка 8 Марта — тюльпаны и подарки"`
+
diff --git a/api/routes/ads.js b/api/routes/ads.js
new file mode 100644
index 0000000000000000000000000000000000000000..e2b4f9705d1b2e2c709bd0b35e2ee888823b1cdd
--- /dev/null
+++ b/api/routes/ads.js
@@ -0,0 +1,59 @@
+import { Router } from 'express';
+import Ad from '../../models/Ad.js';
+
+const router = Router();
+
+const handle = (fn) => async (req, res, next) => {
+  try {
+    await fn(req, res, next);
+  } catch (error) {
+    next(error);
+  }
+};
+
+router.get(
+  '/',
+  handle(async (req, res) => {
+    const { limit = 20, categoryId, subcategoryId, seasonCode } = req.query;
+    const filters = { status: 'active' };
+
+    if (categoryId) filters.categoryId = categoryId;
+    if (subcategoryId) filters.subcategoryId = subcategoryId;
+    if (seasonCode) filters.seasonCode = seasonCode;
+
+    const items = await Ad.find(filters)
+      .sort({ createdAt: -1 })
+      .limit(Math.min(Number(limit) || 20, 100));
+
+    res.json({ items });
+  })
+);
+
+router.get(
+  '/:id',
+  handle(async (req, res) => {
+    const ad = await Ad.findById(req.params.id);
+    if (!ad) {
+      return res.status(404).json({ message: 'Объявление не найдено' });
+    }
+    res.json(ad);
+  })
+);
+
+router.post(
+  '/',
+  handle(async (req, res) => {
+    const { title, categoryId, subcategoryId, price, sellerTelegramId } = req.body;
+
+    if (!title || !categoryId || !subcategoryId || price === undefined || !sellerTelegramId) {
+      return res.status(400).json({
+        message: 'Необходимо указать title, categoryId, subcategoryId, price и sellerTelegramId',
+      });
+    }
+
+    const ad = await Ad.create(req.body);
+    res.status(201).json(ad);
+  })
+);
+
+export default router;
diff --git a/api/routes/categories.js b/api/routes/categories.js
new file mode 100644
index 0000000000000000000000000000000000000000..cd422fce075fc2339c08a01e7515d430f6e981f7
--- /dev/null
+++ b/api/routes/categories.js
@@ -0,0 +1,52 @@
+import { Router } from 'express';
+import Category from '../../models/Category.js';
+
+const router = Router();
+
+function buildTree(categories) {
+  const map = new Map();
+  categories.forEach((cat) => {
+    map.set(cat.slug, { ...cat.toObject(), subcategories: [] });
+  });
+
+  const roots = [];
+
+  map.forEach((category) => {
+    if (category.parentSlug) {
+      const parent = map.get(category.parentSlug);
+      if (parent) {
+        parent.subcategories.push(category);
+      }
+    } else {
+      roots.push(category);
+    }
+  });
+
+  const sortRecursive = (nodes) => {
+    nodes.sort((a, b) => a.sortOrder - b.sortOrder);
+    nodes.forEach((n) => sortRecursive(n.subcategories));
+  };
+
+  sortRecursive(roots);
+
+  const stripInternal = (node) => ({
+    slug: node.slug,
+    name: node.name,
+    parentSlug: node.parentSlug,
+    subcategories: node.subcategories.map(stripInternal),
+  });
+
+  return roots.map(stripInternal);
+}
+
+router.get('/', async (_req, res, next) => {
+  try {
+    const categories = await Category.find().sort({ sortOrder: 1, slug: 1 });
+    const tree = buildTree(categories);
+    res.json(tree);
+  } catch (error) {
+    next(error);
+  }
+});
+
+export default router;
diff --git a/api/routes/orders.js b/api/routes/orders.js
new file mode 100644
index 0000000000000000000000000000000000000000..e2cd405e3b4b9a642c0515ac83f8699ee5750703
--- /dev/null
+++ b/api/routes/orders.js
@@ -0,0 +1,83 @@
+import { Router } from 'express';
+import Ad from '../../models/Ad.js';
+import Order from '../../models/Order.js';
+
+const router = Router();
+
+const handle = (fn) => async (req, res, next) => {
+  try {
+    await fn(req, res, next);
+  } catch (error) {
+    next(error);
+  }
+};
+
+router.post(
+  '/',
+  handle(async (req, res) => {
+    const { buyerTelegramId, buyerName, buyerUsername, buyerPhone, items, seasonCode, comment } =
+      req.body;
+
+    if (!buyerTelegramId) {
+      return res.status(400).json({ message: 'buyerTelegramId обязателен' });
+    }
+
+    if (!Array.isArray(items) || items.length === 0) {
+      return res.status(400).json({ message: 'Необходимо передать хотя бы один товар' });
+    }
+
+    const adIds = items.map((item) => item.adId).filter(Boolean);
+    if (!adIds.length) {
+      return res.status(400).json({ message: 'Каждый товар должен содержать adId' });
+    }
+
+    const ads = await Ad.find({ _id: { $in: adIds } }).lean();
+    const adsMap = new Map(ads.map((ad) => [ad._id.toString(), ad]));
+
+    const orderItems = [];
+
+    for (const item of items) {
+      const ad = adsMap.get(String(item.adId));
+      if (!ad) {
+        return res.status(400).json({ message: `Объявление ${item.adId} не найдено` });
+      }
+
+      const quantity = Number(item.quantity) || 1;
+
+      orderItems.push({
+        adId: ad._id,
+        title: ad.title,
+        quantity,
+        price: ad.price,
+        sellerTelegramId: ad.sellerTelegramId,
+      });
+    }
+
+    const order = await Order.create({
+      buyerTelegramId,
+      buyerName,
+      buyerUsername,
+      buyerPhone,
+      items: orderItems,
+      seasonCode: seasonCode ?? null,
+      comment,
+    });
+
+    res.status(201).json(order);
+  })
+);
+
+router.get(
+  '/:buyerTelegramId',
+  handle(async (req, res) => {
+    const buyerTelegramId = Number(req.params.buyerTelegramId);
+    if (!buyerTelegramId) {
+      return res.status(400).json({ message: 'Некорректный buyerTelegramId' });
+    }
+
+    const orders = await Order.find({ buyerTelegramId }).sort({ createdAt: -1 });
+    res.json(orders);
+  })
+);
+
+export default router;
diff --git a/api/routes/seasons.js b/api/routes/seasons.js
new file mode 100644
index 0000000000000000000000000000000000000000..0d468527e603a800ab6e309e60608c9db466063e
--- /dev/null
+++ b/api/routes/seasons.js
@@ -0,0 +1,15 @@
+import { Router } from 'express';
+import Season from '../../models/Season.js';
+
+const router = Router();
+
+router.get('/', async (_req, res, next) => {
+  try {
+    const seasons = await Season.find();
+    res.json(seasons);
+  } catch (error) {
+    next(error);
+  }
+});
+
+export default router;
diff --git a/api/routes/users.js b/api/routes/users.js
new file mode 100644
index 0000000000000000000000000000000000000000..ba711b1aa01340e9322e6aa6d693d403f7023bed
--- /dev/null
+++ b/api/routes/users.js
@@ -0,0 +1,9 @@
+import { Router } from 'express';
+
+const router = Router();
+
+router.get('/', (_req, res) => {
+  res.status(501).json({ message: 'User endpoints are not implemented yet' });
+});
+
+export default router;
diff --git a/api/server.js b/api/server.js
new file mode 100644
index 0000000000000000000000000000000000000000..f4499cf739a282ff85bbc7a06b90f4eb1e236162
--- /dev/null
+++ b/api/server.js
@@ -0,0 +1,15 @@
+import express from 'express';
+import cors from 'cors';
+
+export function createServer() {
+  const app = express();
+
+  app.use(cors());
+  app.use(express.json());
+
+  app.get('/', (_req, res) => {
+    res.send('API работает. KETMAR Market backend запущен.');
+  });
+
+  return app;
+}
diff --git a/bot/bot.js b/bot/bot.js
new file mode 100644
index 0000000000000000000000000000000000000000..64b5e868ea75990c3c5f4a806087d1b3ab9fddbc
--- /dev/null
+++ b/bot/bot.js
@@ -0,0 +1,33 @@
+import { Telegraf } from 'telegraf';
+import { BOT_TOKEN } from '../config/config.js';
+
+export function startBot() {
+  if (!BOT_TOKEN) {
+    console.warn('[bot] BOT_TOKEN не задан, бот не будет запущен');
+    return null;
+  }
+
+  const bot = new Telegraf(BOT_TOKEN);
+
+  bot.start(async (ctx) => {
+    await ctx.reply(
+      'Привет! Я бот маркетплейса объявлений. Доступные команды:\n' +
+        '/myid — показать ваш Telegram ID'
+    );
+  });
+
+  bot.command('myid', async (ctx) => {
+    const user = ctx.from;
+    await ctx.reply(
+      `ID: ${user.id}\nUsername: ${user.username || '—'}\nИмя: ${user.first_name || '—'}`
+    );
+  });
+
+  bot.launch();
+  console.log('[bot] Bot launched');
+
+  process.once('SIGINT', () => bot.stop('SIGINT'));
+  process.once('SIGTERM', () => bot.stop('SIGTERM'));
+
+  return bot;
+}
diff --git a/config/config.js b/config/config.js
new file mode 100644
index 0000000000000000000000000000000000000000..e609079a1476a6815ba105a77bf404bffae99431
--- /dev/null
+++ b/config/config.js
@@ -0,0 +1,8 @@
+import dotenv from 'dotenv';
+
+dotenv.config();
+
+export const PORT = process.env.PORT || 3000;
+export const BOT_TOKEN = process.env.BOT_TOKEN || '';
+export const MONGO_URL = process.env.MONGO_URL || 'mongodb://localhost:27017/miniapp';
+export const API_BASE_URL = process.env.API_BASE_URL || 'http://localhost:3000';
diff --git a/index.js b/index.js
new file mode 100644
index 0000000000000000000000000000000000000000..5a5659dcb76481a117b365220dcd5b764a08074c
--- /dev/null
+++ b/index.js
@@ -0,0 +1,24 @@
+import { createServer } from './api/server.js';
+import { BOT_TOKEN, PORT } from './config/config.js';
+import { startBot } from './bot/bot.js';
+import { connectDB } from './services/db.js';
+
+async function bootstrap() {
+  await connectDB();
+
+  const app = createServer();
+  app.listen(PORT, () => {
+    console.log(`[api] Listening on port ${PORT}`);
+  });
+
+  if (BOT_TOKEN) {
+    startBot();
+  } else {
+    console.warn('[bot] BOT_TOKEN не указан, бот не запущен');
+  }
+}
+
+bootstrap().catch((error) => {
+  console.error('[bootstrap] Failed to start application', error);
+  process.exit(1);
+});
diff --git a/models/Ad.js b/models/Ad.js
new file mode 100644
index 0000000000000000000000000000000000000000..7b0e82768618c1361f095a323879846a0e1a83bd
--- /dev/null
+++ b/models/Ad.js
@@ -0,0 +1,152 @@
+import mongoose from 'mongoose';
+
+const locationSchema = new mongoose.Schema(
+  {
+    lat: { type: Number, required: true },
+    lng: { type: Number, required: true },
+  },
+  { _id: false }
+);
+
+const DAY_MS = 24 * 60 * 60 * 1000;
+
+const adSchema = new mongoose.Schema(
+  {
+    title: {
+      type: String,
+      required: true,
+      trim: true,
+      minlength: 3,
+      maxlength: 200,
+    },
+    description: {
+      type: String,
+      trim: true,
+      maxlength: 4000,
+    },
+    categoryId: {
+      type: String,
+      required: true,
+      trim: true,
+      lowercase: true,
+    },
+    subcategoryId: {
+      type: String,
+      trim: true,
+      lowercase: true,
+      default: null,
+    },
+    price: {
+      type: Number,
+      required: true,
+      min: 0,
+    },
+    currency: {
+      type: String,
+      required: true,
+      trim: true,
+      uppercase: true,
+      default: 'BYN',
+    },
+    attributes: {
+      type: mongoose.Schema.Types.Mixed,
+      default: {},
+    },
+    photos: {
+      type: [String],
+      default: [],
+    },
+    sellerTelegramId: {
+      type: Number,
+      required: true,
+      index: true,
+    },
+    deliveryType: {
+      type: String,
+      enum: ['pickup_only', 'delivery_only', 'delivery_and_pickup'],
+      default: null,
+    },
+    deliveryRadiusKm: {
+      type: Number,
+      min: 0,
+      default: null,
+    },
+    location: locationSchema,
+    seasonCode: {
+      type: String,
+      trim: true,
+      lowercase: true,
+      default: null,
+    },
+    status: {
+      type: String,
+      enum: ['active', 'expired', 'archived', 'hidden'],
+      required: true,
+      default: 'active',
+    },
+    moderationStatus: {
+      type: String,
+      enum: ['pending', 'approved', 'rejected'],
+      required: true,
+      default: 'pending',
+    },
+    lifetimeDays: {
+      type: Number,
+      required: true,
+      min: 1,
+    },
+    validUntil: {
+      type: Date,
+    },
+    isLiveSpot: {
+      type: Boolean,
+      required: true,
+      default: false,
+    },
+  },
+  {
+    timestamps: true,
+  }
+);
+
+function computeValidUntil(createdAt, lifetimeDays) {
+  if (!createdAt || !lifetimeDays) return undefined;
+  return new Date(createdAt.getTime() + lifetimeDays * DAY_MS);
+}
+
+adSchema.pre('validate', function setValidUntil(next) {
+  if (!this.validUntil && this.lifetimeDays) {
+    const baseDate = this.createdAt || new Date();
+    this.validUntil = computeValidUntil(baseDate, this.lifetimeDays);
+  }
+  next();
+});
+
+adSchema.pre('findOneAndUpdate', async function ensureValidUntil(next) {
+  const update = this.getUpdate() || {};
+  const hasValidUntilInUpdate =
+    Object.prototype.hasOwnProperty.call(update, 'validUntil') ||
+    (update.$set && Object.prototype.hasOwnProperty.call(update.$set, 'validUntil'));
+
+  if (hasValidUntilInUpdate) return next();
+
+  const lifetimeFromUpdate = update.lifetimeDays ?? update.$set?.lifetimeDays;
+  const doc = await this.model.findOne(this.getQuery()).lean();
+
+  if (!doc) return next();
+  if (!lifetimeFromUpdate && doc.validUntil) return next();
+
+  const lifetimeDays = lifetimeFromUpdate ?? doc.lifetimeDays;
+  if (!lifetimeDays) return next();
+
+  const baseDate = doc.createdAt ? new Date(doc.createdAt) : new Date();
+  const validUntil = computeValidUntil(baseDate, lifetimeDays);
+
+  const newUpdate = { ...update };
+  newUpdate.$set = { ...(update.$set || {}), validUntil };
+  this.setUpdate(newUpdate);
+
+  next();
+});
+
+export default mongoose.model('Ad', adSchema);
diff --git a/models/Category.js b/models/Category.js
new file mode 100644
index 0000000000000000000000000000000000000000..2d2ea9e6cff2641f0c653c598a6769d6e5bb727b
--- /dev/null
+++ b/models/Category.js
@@ -0,0 +1,36 @@
+import mongoose from 'mongoose';
+
+const categorySchema = new mongoose.Schema(
+  {
+    slug: {
+      type: String,
+      required: true,
+      unique: true,
+      index: true,
+      trim: true,
+      lowercase: true,
+    },
+    name: {
+      type: String,
+      required: true,
+      trim: true,
+    },
+    parentSlug: {
+      type: String,
+      default: null,
+      trim: true,
+      lowercase: true,
+    },
+    sortOrder: {
+      type: Number,
+      required: true,
+      default: 0,
+      min: 0,
+    },
+  },
+  {
+    timestamps: true,
+  }
+);
+
+export default mongoose.model('Category', categorySchema);
diff --git a/models/Order.js b/models/Order.js
new file mode 100644
index 0000000000000000000000000000000000000000..bf10846443b158cd9cd870ba1ea860fbde8a6240
--- /dev/null
+++ b/models/Order.js
@@ -0,0 +1,82 @@
+import mongoose from 'mongoose';
+
+const orderItemSchema = new mongoose.Schema(
+  {
+    adId: {
+      type: mongoose.Schema.Types.ObjectId,
+      required: true,
+      ref: 'Ad',
+    },
+    title: {
+      type: String,
+      required: true,
+      trim: true,
+    },
+    quantity: {
+      type: Number,
+      required: true,
+      min: 1,
+    },
+    price: {
+      type: Number,
+      required: true,
+      min: 0,
+    },
+    sellerTelegramId: {
+      type: Number,
+      required: true,
+    },
+  },
+  { _id: false }
+);
+
+const orderSchema = new mongoose.Schema(
+  {
+    buyerTelegramId: {
+      type: Number,
+      required: true,
+      index: true,
+    },
+    buyerName: {
+      type: String,
+      trim: true,
+    },
+    buyerUsername: {
+      type: String,
+      trim: true,
+    },
+    buyerPhone: {
+      type: String,
+      trim: true,
+    },
+    items: {
+      type: [orderItemSchema],
+      required: true,
+      validate: {
+        validator: (items) => Array.isArray(items) && items.length > 0,
+        message: 'Order must contain at least one item.',
+      },
+    },
+    status: {
+      type: String,
+      enum: ['new', 'sent_to_sellers', 'processed', 'cancelled'],
+      required: true,
+      default: 'new',
+    },
+    seasonCode: {
+      type: String,
+      trim: true,
+      lowercase: true,
+      default: null,
+    },
+    comment: {
+      type: String,
+      trim: true,
+    },
+  },
+  {
+    timestamps: true,
+  }
+);
+
+export default mongoose.model('Order', orderSchema);
diff --git a/models/Season.js b/models/Season.js
new file mode 100644
index 0000000000000000000000000000000000000000..0d100dfdc921168a90857f3a96cf52dc2cd6e4d2
--- /dev/null
+++ b/models/Season.js
@@ -0,0 +1,39 @@
+import mongoose from 'mongoose';
+
+const seasonSchema = new mongoose.Schema(
+  {
+    code: {
+      type: String,
+      required: true,
+      unique: true,
+      index: true,
+      trim: true,
+      lowercase: true,
+    },
+    name: {
+      type: String,
+      required: true,
+      trim: true,
+    },
+    description: {
+      type: String,
+      trim: true,
+    },
+    startDate: {
+      type: Date,
+    },
+    endDate: {
+      type: Date,
+    },
+    isActive: {
+      type: Boolean,
+      required: true,
+      default: false,
+    },
+  },
+  {
+    timestamps: true,
+  }
+);
+
+export default mongoose.model('Season', seasonSchema);
diff --git a/models/User.js b/models/User.js
new file mode 100644
index 0000000000000000000000000000000000000000..cec92523aa104f680661bbb4f08b57c76ad3d2a6
--- /dev/null
+++ b/models/User.js
@@ -0,0 +1,77 @@
+import mongoose from 'mongoose';
+
+const locationSchema = new mongoose.Schema(
+  {
+    lat: {
+      type: Number,
+      required: true,
+    },
+    lng: {
+      type: Number,
+      required: true,
+    },
+    updatedAt: {
+      type: Date,
+      required: true,
+    },
+  },
+  { _id: false }
+);
+
+const userSchema = new mongoose.Schema(
+  {
+    telegramId: {
+      type: Number,
+      required: true,
+      unique: true,
+      index: true,
+    },
+    username: {
+      type: String,
+      trim: true,
+    },
+    firstName: {
+      type: String,
+      trim: true,
+    },
+    lastName: {
+      type: String,
+      trim: true,
+    },
+    role: {
+      type: String,
+      enum: ['buyer', 'seller', 'both'],
+      required: true,
+    },
+    phoneVerified: {
+      type: Boolean,
+      default: false,
+    },
+    verifiedPhone: {
+      type: String,
+      trim: true,
+    },
+    instagram: {
+      type: String,
+      trim: true,
+    },
+    showUsername: {
+      type: Boolean,
+      default: false,
+    },
+    showPhone: {
+      type: Boolean,
+      default: false,
+    },
+    showInstagram: {
+      type: Boolean,
+      default: false,
+    },
+    location: locationSchema,
+  },
+  {
+    timestamps: true,
+  }
+);
+
+export default mongoose.model('User', userSchema);
diff --git a/package.json b/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..d8a7c924beabcfdcc96934246eb227e94f06bc74
--- /dev/null
+++ b/package.json
@@ -0,0 +1,34 @@
+{
+  "name": "miniapp",
+  "version": "1.0.0",
+  "description": "Каркас backend и Telegram-бота для маркетплейса",
+  "main": "index.js",
+  "type": "module",
+  "scripts": {
+    "start": "node index.js",
+    "dev": "NODE_ENV=development nodemon index.js",
+    "seed": "node scripts/seedCategories.js"
+  },
+  "engines": {
+    "node": ">=18"
+  },
+  "keywords": [
+    "express",
+    "telegram",
+    "telegraf",
+    "marketplace"
+  ],
+  "author": "",
+  "license": "ISC",
+  "dependencies": {
+    "axios": "^1.7.7",
+    "cors": "^2.8.5",
+    "dotenv": "^16.4.5",
+    "express": "^4.19.2",
+    "mongoose": "^8.7.0",
+    "telegraf": "^4.16.3"
+  },
+  "devDependencies": {
+    "nodemon": "^3.1.7"
+  }
+}
diff --git a/replit.nix b/replit.nix
new file mode 100644
index 0000000000000000000000000000000000000000..3bf728293e925c753ac2fbeec7261bba22f1d22e
--- /dev/null
+++ b/replit.nix
@@ -0,0 +1,6 @@
+{ pkgs }: {
+  deps = [
+    pkgs.nodejs-18_x
+    pkgs.nodePackages.npm
+  ];
+}
diff --git a/scripts/seedCategories.js b/scripts/seedCategories.js
new file mode 100644
index 0000000000000000000000000000000000000000..d72e57a7d958549585fb695f7da9dfff65fcb43b
--- /dev/null
+++ b/scripts/seedCategories.js
@@ -0,0 +1,74 @@
+import mongoose from 'mongoose';
+import { MONGO_URL } from '../config/config.js';
+import Category from '../models/Category.js';
+import Season from '../models/Season.js';
+
+const categoriesSeed = [
+  // Авто
+  { slug: 'auto', name: 'Авто', parentSlug: null, sortOrder: 1 },
+  { slug: 'cars', name: 'Легковые', parentSlug: 'auto', sortOrder: 2 },
+  { slug: 'moto', name: 'Мото', parentSlug: 'auto', sortOrder: 3 },
+  { slug: 'trucks', name: 'Грузовики', parentSlug: 'auto', sortOrder: 4 },
+
+  // Недвижимость
+  { slug: 'realty', name: 'Недвижимость', parentSlug: null, sortOrder: 10 },
+  { slug: 'rent_flat', name: 'Аренда квартир', parentSlug: 'realty', sortOrder: 11 },
+  { slug: 'rent_house', name: 'Аренда домов', parentSlug: 'realty', sortOrder: 12 },
+  { slug: 'country_base', name: 'Загородные базы', parentSlug: 'realty', sortOrder: 13 },
+
+  // Фермерские товары
+  { slug: 'farm', name: 'Фермерские товары', parentSlug: null, sortOrder: 20 },
+  { slug: 'berries', name: 'Ягоды', parentSlug: 'farm', sortOrder: 21 },
+  { slug: 'vegetables', name: 'Овощи', parentSlug: 'farm', sortOrder: 22 },
+  { slug: 'fruits', name: 'Фрукты', parentSlug: 'farm', sortOrder: 23 },
+  { slug: 'eggs', name: 'Яйца', parentSlug: 'farm', sortOrder: 24 },
+  { slug: 'milk', name: 'Молочная продукция', parentSlug: 'farm', sortOrder: 25 },
+  { slug: 'meat', name: 'Мясо', parentSlug: 'farm', sortOrder: 26 },
+
+  // Ремесленники
+  { slug: 'craft', name: 'Ремесленники', parentSlug: null, sortOrder: 30 },
+  { slug: 'cakes', name: 'Торты', parentSlug: 'craft', sortOrder: 31 },
+  { slug: 'eclairs', name: 'Эклеры', parentSlug: 'craft', sortOrder: 32 },
+  { slug: 'cupcakes', name: 'Капкейки', parentSlug: 'craft', sortOrder: 33 },
+  { slug: 'sweets_sets', name: 'Наборы сладостей', parentSlug: 'craft', sortOrder: 34 },
+
+  // Услуги
+  { slug: 'services', name: 'Услуги', parentSlug: null, sortOrder: 40 },
+  { slug: 'build', name: 'Строительство и ремонт', parentSlug: 'services', sortOrder: 41 },
+  { slug: 'delivery_services', name: 'Доставка и курьеры', parentSlug: 'services', sortOrder: 42 },
+];
+
+const seasonsSeed = [
+  {
+    code: 'march8_tulips',
+    name: 'Ярмарка 8 Марта — тюльпаны и подарки',
+    description: 'Сезонная подборка тюльпанов, букетов и подарков к 8 Марта.',
+    startDate: new Date('2025-03-01T00:00:00Z'),
+    endDate: new Date('2025-03-10T23:59:59Z'),
+    isActive: true,
+  },
+];
+
+async function seed() {
+  await mongoose.connect(MONGO_URL, { autoIndex: true });
+  console.log('[seed] Connected to MongoDB');
+
+  await Category.deleteMany({});
+  await Season.deleteMany({});
+
+  await Category.insertMany(categoriesSeed);
+  await Season.insertMany(seasonsSeed);
+
+  console.log(`[seed] Inserted ${categoriesSeed.length} categories and ${seasonsSeed.length} seasons`);
+  await mongoose.disconnect();
+}
+
+seed()
+  .then(() => {
+    console.log('[seed] Done');
+    process.exit(0);
+  })
+  .catch((error) => {
+    console.error('[seed] Error', error);
+    process.exit(1);
+  });
diff --git a/services/db.js b/services/db.js
new file mode 100644
index 0000000000000000000000000000000000000000..562cd579f3ea0123dcd3fe28cc8b85dc88809281
--- /dev/null
+++ b/services/db.js
@@ -0,0 +1,12 @@
+import mongoose from 'mongoose';
+import { MONGO_URL } from '../config/config.js';
+
+export async function connectDB() {
+  try {
+    await mongoose.connect(MONGO_URL, { autoIndex: true });
+    console.log('[db] Connected to MongoDB');
+  } catch (error) {
+    console.error('[db] MongoDB connection error:', error.message);
+    process.exit(1);
+  }
+}
 
EOF
)